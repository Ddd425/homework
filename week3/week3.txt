week3---标准I/o库
1）库文件
库文件就是对公共代码的一种组织形式。
其要点就是把公共的（也就是可以被多次复用的）目标代码从项目中分离出来，统一存放到库文件中，项目要用到这些代码的时候，在编译或者运行的时候从库文件中取得目标代码即可。
2）静态库与动态库
如果程序是在编译时加载库文件的，就是使用了静态库。如果是在运行时加载目标代码，就成为动态库。换句话说，如果是使用静态库，则静态库代码在编译时就拷贝到了程序的代码段，程序的体积会膨胀。如果使用动态库，则程序中只保留库文件的名字和函数名，在运行时去查找库文件和函数体，程序的体积基本变化不大。
静态库的原则是“以空间换时间”，增加程序体积，减少运行时间;
动态库则是“以时间换空间”，增加了运行时间，但减少了程序本身的体积。
3）标准IO缓冲详解
在标准I/O中，核心对象是流。所谓流，它是一个过程，所有的I/O操作都是简单的从程序的移进或移出，我们把这种字符流叫做流。标准I/O基于流的操作都是缓存文件系统。
4）系统I/O函数
open函数
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
参数：
falgs 设置：
 
O_RDONLY                     以只读方式打开文件
 
O_WRONLY                    以只写的方式打开文件
 
O_RDWR                        以读写的方式打开
 
O_CREAT                       如果文件不存在则创建文件
 
O_EXCL                          如果文件存在，则强制  open() 操作失败
 
O_TRUNC                       如果文件存在，将文件清零
 
O_APPEND                     把文件添加内容的指针设到文件的结束处
 
mode 设置：
 
文件权限 = 给定对的文件权限   &    本地掩码（取反）
 
例如：
 
设定权限     0777
 
umask 出来的本地掩码是   0002
777  ----------------------------二进制               111 111 111
002  ----------------------------二进制  00  000 010    取反后得   111 111 101
&   （按位与）
实际权限  111 111 101 
即实际权限为 0775
若成功返回文件描述符；若出错，返回-1
2.read函数
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
 
返回值：
读到的字节数，若已到达文件结尾，返回 0 ；若出错 返回 -1  。 
3.write函数
函数原型：
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
 
返回值：
若成功，返回已写的字节数；若出错 返回 -1 。
open,read,write 函数的运用：从一个文件汇总读取内容后，写入另一个文件中


4、lseek函数
 
函数原型：
 
#include <sys/types.h>
#include <unistd.h>
 
off_t lseek(int fd, off_t offset, int whence);
 
作用： 设置文件偏移量。
 
若文件的偏移量大于当前文件的长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。位于文件中没有写过的字节都被 读为0.、
 
                         文件中的空洞并不要求在磁盘上占用存储区。
 
               参数：
 
whence的取值：
 
      
     SEEK_SET               文件的便宜位置设置为距开始位置 offset 个字节
            
     SEEK_CUR               文件的便宜位置设置为当前值 + offset  ，offset 的值可正可负
             
     SEEK_END               文件的便宜位置设置为文件长度 +offset ，offset 的值只能W为正的，只能向后拓展不能向向拓展         
 
               返回值：
 
    若成功返回文件描述符；若出错，返回-1   
5)文件描述符表
在进程创建时，内核为进程默认创建了0、1、2三个特殊的FD，这就是STDIN、STDOUT和STDERR，
所谓的I/O重定向也就是让已创建的FD指向其他文件。在I/O重定向的过程中，不变的是FD 0/1/2代表STDIN/STDOUT/STDERR，变化的是文件描述符表中FD 0/1/2对应的具体文件。
6）1. memset()函数原型是extern void *memset(void *buffer, int c, int count)        buffer：为指针或是数组, 
              c：是赋给buffer的值,
       count：是buffer的长度.

       这个函数在socket中多用于清空数组.如:原型是memset(buffer, 0, sizeof(buffer))


2.fopen函数
使用 <stdio.h> 头文件中的 fopen() 函数即可打开文件，它的用法为： 
FILE *fopen(char *filename, char *mode);
filename为文件名（包括文件路径），mode为打开方式，它们都是字符串。
返回值：fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回。
"r"
以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。
"w"
以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
"a"
以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
"r+"
以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。
"w+"
以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。
"a+"
以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。
3.freopen函数
函数名：freopen 
声明：FILE *freopen( const char *path, const char *mode, FILE *stream ); 
所在文件： stdio.h 
参数说明： 
path: 文件名，用于存储输入输出的自定义文件名。 
mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。 
stream: 一个文件，通常使用标准流文件。 
返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。（一般可以不使用它的返回值） 
功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。 
fgets() 的原型为： 
# include <stdio.h>
char *fgets(char *s, int size, FILE *stream);
fgets() 虽然比 gets() 安全，但安全是要付出代价的，代价就是它的使用比 gets() 要麻烦一点，有三个参数。它的功能是从 stream 流中读取 size 个字符存储到字符指针变量 s 所指向的内存空间。它的返回值是一个指针，指向字符串中第一个字符的地址。

其中：s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。











